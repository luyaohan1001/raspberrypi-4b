#include <linux/module.h>
#include <linux/init.h>
#include <linux/proc_fs.h>
#include <linux/i2c.h>
#include <linux/delay.h>

/* Meta Information */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Luyao Han");
MODULE_DESCRIPTION("Linux kernel module driver for ssd1306 oled display");

static struct i2c_client *oled_client;

static int my_oled_probe(struct i2c_client *client, const struct i2c_device_id *id);
static int my_oled_remove(struct i2c_client *client);


static struct of_device_id my_driver_id[] = {
    {
        .compatible = "brightlight, my_oled"
    }, { /*sentinel*/ }
};

MODULE_DEVICE_TABLE(of, my_driver_id);

static struct i2c_device_id my_oled[] = {
    {
        "my_oled", 0
    }, { /*sentinel*/ }
};
MODULE_DEVICE_TABLE(i2c, my_oled);

static struct i2c_driver my_driver = {
    .probe = my_oled_probe,
    .remove = my_oled_remove,
    .id_table = my_oled,
    .driver = {
        .name = "my_oled",
        .of_match_table = my_driver_id,
    },
};



/* Entery in proc file system. This is so that this driver can be interacted with user space program. */
static struct proc_dir_entry *proc_file;

static ssize_t my_write(struct file *File, const char *user_buffer, size_t count, loff_t *offs) {
    long val;
    if ( 0 == kstrtol(user_buffer, 0, &val)) {
        i2c_smbus_write_byte(oled_client, (u8)val);
    }
    return count;
}


static ssize_t my_read(struct file *File, char *user_buffer, size_t count, loff_t *offs) {
    u8 read_val;
    read_val = i2c_smbus_read_byte(oled_client);
    return sprintf(user_buffer, "%d\n", read_val);
}

static struct proc_ops fops = {
    .proc_write = my_write,
    .proc_read = my_read,
};


static int I2C_Write(unsigned char *buf, unsigned int len)
{
  /*
  ** Sending Start condition, Slave address with R/W bit, 
  ** ACK/NACK and Stop condtions will be handled internally.
  */ 
  int ret = i2c_master_send(oled_client, buf, len);
  
  return ret;
}

static void SSD1306_Write(bool is_cmd, unsigned char data)
{
  unsigned char buf[2] = {0};
  int ret;
  
  /*
  ** First byte is always control byte. Data is followed after that.
  **
  ** There are two types of data in SSD_1306 OLED.
  ** 1. Command
  ** 2. Data
  **
  ** Control byte decides that the next byte is, command or data.
  **
  ** -------------------------------------------------------                        
  ** |              Control byte's | 6th bit  |   7th bit  |
  ** |-----------------------------|----------|------------|    
  ** |   Command                   |   0      |     0      |
  ** |-----------------------------|----------|------------|
  ** |   data                      |   1      |     0      |
  ** |-----------------------------|----------|------------|
  ** 
  ** Please refer the datasheet for more information. 
  **    
  */ 
  if( is_cmd == true )
  {
      buf[0] = 0x00;
  }
  else
  {
      buf[0] = 0x40;
  }
  
  buf[1] = data;
  
  ret = I2C_Write(buf, 2);
}



static int SSD1306_DisplayInit(void)
{
  msleep(100);               // delay

  /*
  ** Commands to initialize the SSD_1306 OLED Display
  */
  SSD1306_Write(true, 0xAE); // Entire Display OFF
  SSD1306_Write(true, 0xD5); // Set Display Clock Divide Ratio and Oscillator Frequency
  SSD1306_Write(true, 0x80); // Default Setting for Display Clock Divide Ratio and Oscillator Frequency that is recommended
  SSD1306_Write(true, 0xA8); // Set Multiplex Ratio
  SSD1306_Write(true, 0x3F); // 64 COM lines
  SSD1306_Write(true, 0xD3); // Set display offset
  SSD1306_Write(true, 0x00); // 0 offset
  SSD1306_Write(true, 0x40); // Set first line as the start line of the display
  SSD1306_Write(true, 0x8D); // Charge pump
  SSD1306_Write(true, 0x14); // Enable charge dump during display on
  SSD1306_Write(true, 0x20); // Set memory addressing mode
  SSD1306_Write(true, 0x00); // Horizontal addressing mode
  SSD1306_Write(true, 0xA1); // Set segment remap with column address 127 mapped to segment 0
  SSD1306_Write(true, 0xC8); // Set com output scan direction, scan from com63 to com 0
  SSD1306_Write(true, 0xDA); // Set com pins hardware configuration
  SSD1306_Write(true, 0x12); // Alternative com pin configuration, disable com left/right remap
  SSD1306_Write(true, 0x81); // Set contrast control
  SSD1306_Write(true, 0x80); // Set Contrast to 128
  SSD1306_Write(true, 0xD9); // Set pre-charge period
  SSD1306_Write(true, 0xF1); // Phase 1 period of 15 DCLK, Phase 2 period of 1 DCLK
  SSD1306_Write(true, 0xDB); // Set Vcomh deselect level
  SSD1306_Write(true, 0x20); // Vcomh deselect level ~ 0.77 Vcc
  SSD1306_Write(true, 0xA4); // Entire display ON, resume to RAM content display
  SSD1306_Write(true, 0xA6); // Set Display in Normal Mode, 1 = ON, 0 = OFF
  SSD1306_Write(true, 0x2E); // Deactivate scroll
  SSD1306_Write(true, 0xAF); // Display ON in normal mode
  
  //Clear the display
  // SSD1306_Fill(0x00);
  return 0;
}

static int my_oled_probe(struct i2c_client *client, const struct i2c_device_id *id) {
    printk("Entered my_oled_probe function\n");
    if (client->addr != 0x3c) {
        printk("Wrong I2C address.\n");
        return -1;
    }

    oled_client = client;
    proc_file = proc_create("my_oled", 0666, NULL, &fops);


    SSD1306_DisplayInit();
  
    //Set cursor
    // SSD1306_SetCursor(0,0);
    // SSD1306_StartScrollHorizontal( true, 0, 2);

    //Write String to OLED
    // SSD1306_String("Welcome\nTo\nEmbeTronicX\n\n");
  
    pr_info("OLED Probed!!!\n");


    return 0;
}

static int my_oled_remove(struct i2c_client *client) {
    proc_remove(proc_file);
    return 0;
}

module_i2c_driver(my_driver);